#include "test/test.h"

#include "drivers/acpi.h"

// Special __start_<section> and __stop_<section> symbols generated by GCC.
extern const struct test_info __start_test_rodata;
extern const struct test_info __stop_test_rodata;

const struct test_info *const tests_begin = &__start_test_rodata;
const struct test_info *const tests_end = &__stop_test_rodata;

// Internal-only helper function to match against a single clause of a
// conjunctive selection.
//
// Assumes there are no conjunctions (no ',') in the pattern.
bool _test_is_match_single(const struct test_info *test, const char *selection,
                           size_t selection_len) {
  // Empty selection matches all patterns.
  if (!selection_len) {
    return true;
  }

  const bool match_start = *selection == '^';
  const bool match_end = selection[selection_len - 1] == '$';
  const size_t selection_real_len = selection_len - match_start - match_end;

  const char *name = test->name;
  const size_t name_len = strlen(name);

  // `name` is shorter than the selection.
  if (name_len < selection_real_len) {
    return false;
  }

  // Perform matching at the beginning/end.
  if (match_start && strncmp(name, selection + 1, selection_real_len)) {
    return false;
  }
  if (match_end && strncmp(name + name_len - selection_real_len,
                           selection + match_start, selection_real_len)) {
    return false;
  }
  if (match_start || match_end) {
    return true;
  }

  // If not matched already, look for a substring match.
  for (size_t i = 0; i <= name_len - selection_real_len; ++i) {
    if (!strncmp(name + i, selection + match_start, selection_real_len)) {
      return true;
    }
  }
  return false;
}

bool _test_is_match(const struct test_info *test, const char *selection) {
  assert(selection);
  const size_t n = strlen(selection);

  // If there are multiple patterns, or the results together. Recursion used for
  // simplicity, could technically overflow the stack for very long test
  // patterns. But I don't think this is a real concern.
  //
  // TODO(jlam55555): Rewrite this iteratively with `strtok()`.
  for (size_t i = 0; i < n; ++i) {
    if (selection[i] == ',') {
      return _test_is_match_single(test, selection, i) ||
             _test_is_match(test, selection + i + 1);
    }
  }

  return _test_is_match_single(test, selection, n);
}

// Run all tests.
void run_tests(const char *selection) {
  printf("\r\n" TEST_PREFIX "Running tests with selection '%s'...\r\n",
         selection);

  bool test_passed;

  unsigned tests_collected = 0, tests_passed = 0;
  for (const struct test_info *test = tests_begin; test < tests_end; ++test) {
    if (!_test_is_match(test, selection)) {
      continue;
    }

    test_passed = true;
    printf(TEST_PREFIX "Running test %s...\r\n", test->name);
    test->fn(&test_passed);
    printf(TEST_PREFIX "Test %s\r\n", test_passed ? "PASSED" : "FAILED");

    ++tests_collected;
    tests_passed += test_passed;
  }

  printf(TEST_PREFIX "Done. %u/%u tests passed.\r\n", tests_passed,
         tests_collected);
#ifdef RUNTEST
  acpi_shutdown();
#endif // RUNTEST
}

// Meta-test. Test different patterns that would match itself.
DEFINE_TEST(test__pattern_matcher) {
  const char *pat1 = "test__";
  const struct test_info test1 = {.name = "test__pattern_matcher"};

  TEST_ASSERT(_test_is_match(&test1, pat1));
}
