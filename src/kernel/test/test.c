#include "test/test.h"

#include "drivers/acpi.h"

// Special __start_<section> and __stop_<section> symbols generated by GCC.
extern const struct test_info __start_test_rodata;
extern const struct test_info __stop_test_rodata;

const struct test_info *const tests_begin = &__start_test_rodata;
const struct test_info *const tests_end = &__stop_test_rodata;

// Internal-only helper function to match against a single clause of a
// conjunctive selection.
//
// Assumes there are no conjunctions (no ',') in the pattern.
bool _test_is_match_single(const struct test_info *test, const char *selection,
                           size_t selection_len) {
  // Empty selection matches all patterns.
  if (!selection_len) {
    return true;
  }

  const bool match_start = *selection == '^';
  const bool match_end = selection[selection_len - 1] == '$';
  const size_t selection_real_len = selection_len - match_start - match_end;

  const char *name = test->name;
  const size_t name_len = strlen(name);

  // `name` is shorter than the selection.
  if (name_len < selection_real_len) {
    return false;
  }

  // Perform matching at the beginning/end.
  if (match_start && strncmp(name, selection + 1, selection_real_len)) {
    return false;
  }
  if (match_end && strncmp(name + name_len - selection_real_len,
                           selection + match_start, selection_real_len)) {
    return false;
  }
  if (match_start || match_end) {
    return true;
  }

  // If not matched already, look for a substring match.
  for (size_t i = 0; i <= name_len - selection_real_len; ++i) {
    if (!strncmp(name + i, selection + match_start, selection_real_len)) {
      return true;
    }
  }
  return false;
}

bool _test_is_match(const struct test_info *test, const char *selection) {
  assert(selection);
  const size_t n = strlen(selection);

  // If there are multiple patterns, or the results together. Recursion used for
  // simplicity, could technically overflow the stack for very long test
  // patterns. But I don't think this is a real concern.
  //
  // TODO(jlam55555): Rewrite this iteratively with `strtok()`.
  for (size_t i = 0; i < n; ++i) {
    if (selection[i] == ',') {
      return _test_is_match_single(test, selection, i) ||
             _test_is_match(test, selection + i + 1);
    }
  }

  return _test_is_match_single(test, selection, n);
}

// Run all tests.
void run_tests(const char *selection) {
  printf("\r\n" TEST_PREFIX "Running tests with selection '%s'...\r\n",
         selection);

  bool test_passed;

  unsigned tests_collected = 0, tests_passed = 0;
  for (const struct test_info *test = tests_begin; test < tests_end; ++test) {
    if (!_test_is_match(test, selection)) {
      continue;
    }

    test_passed = true;
    printf(TEST_PREFIX "Running test %s...\r\n", test->name);
    test->fn(&test_passed);
    printf(TEST_PREFIX "Test %s\r\n", test_passed ? "PASSED" : "FAILED");

    ++tests_collected;
    tests_passed += test_passed;
  }

  printf(TEST_PREFIX "Done. %u/%u tests passed.\r\n", tests_passed,
         tests_collected);
#ifdef RUNTEST
  acpi_shutdown();
#endif // RUNTEST
}

DEFINE_TEST(test__pattern_matcher) {
  const char *pat1 = "test__";
  const char *pat2 = "";
  const char *pat3 = "^test__";
  const char *pat4 = "pattern_matcher";
  const char *pat5 = "pattern_matcher$";
  const char *pat6 = "test__pattern_matcher$";
  const char *pat7 = "^test__pattern_matcher$";
  const char *pat8 = "^test__pattern_matcher";
  const char *pat9 = "^1test__pattern_matcher";
  const char *pat10 = "^test__pattern_matcher1";
  const char *pat11 = "test__pattern_matcher1$";
  const char *pat12 = "test__pattern_matcher1";
  const char *pat13 = "__";
  const char *pat14 = "match";

  const struct test_info test1 = {.name = "test__pattern_matcher"};

  TEST_ASSERT(_test_is_match(&test1, pat1));
  TEST_ASSERT(_test_is_match(&test1, pat2));
  TEST_ASSERT(_test_is_match(&test1, pat3));
  TEST_ASSERT(_test_is_match(&test1, pat4));
  TEST_ASSERT(_test_is_match(&test1, pat5));
  TEST_ASSERT(_test_is_match(&test1, pat6));
  TEST_ASSERT(_test_is_match(&test1, pat7));
  TEST_ASSERT(_test_is_match(&test1, pat8));
  TEST_ASSERT(!_test_is_match(&test1, pat9));
  TEST_ASSERT(!_test_is_match(&test1, pat10));
  TEST_ASSERT(!_test_is_match(&test1, pat11));
  TEST_ASSERT(!_test_is_match(&test1, pat12));
  TEST_ASSERT(_test_is_match(&test1, pat13));
  TEST_ASSERT(_test_is_match(&test1, pat14));

  const struct test_info test2 = {.name = "test__foo"};

  TEST_ASSERT(_test_is_match(&test2, pat1));
  TEST_ASSERT(_test_is_match(&test2, pat2));
  TEST_ASSERT(_test_is_match(&test2, pat3));
  TEST_ASSERT(!_test_is_match(&test2, pat4));
  TEST_ASSERT(!_test_is_match(&test2, pat5));
  TEST_ASSERT(!_test_is_match(&test2, pat6));
  TEST_ASSERT(!_test_is_match(&test2, pat7));
  TEST_ASSERT(!_test_is_match(&test2, pat8));
  TEST_ASSERT(!_test_is_match(&test2, pat9));
  TEST_ASSERT(!_test_is_match(&test2, pat10));
  TEST_ASSERT(!_test_is_match(&test2, pat11));
  TEST_ASSERT(!_test_is_match(&test2, pat12));
  TEST_ASSERT(_test_is_match(&test2, pat13));
  TEST_ASSERT(!_test_is_match(&test2, pat14));

  const struct test_info test3 = {.name = "bar__hello"};

  TEST_ASSERT(!_test_is_match(&test3, pat1));
  TEST_ASSERT(_test_is_match(&test3, pat2));
  TEST_ASSERT(!_test_is_match(&test3, pat3));
}

DEFINE_TEST(test__conjunctive_simple_patterns) {
  const char *pat1 = "foo";
  const char *pat2 = "bar";
  const char *pat3 = "foo,bar";

  const struct test_info test1 = {.name = "foo"};
  const struct test_info test2 = {.name = "bar"};

  TEST_ASSERT(_test_is_match(&test1, pat1));
  TEST_ASSERT(!_test_is_match(&test1, pat2));
  TEST_ASSERT(_test_is_match(&test1, pat3));

  TEST_ASSERT(!_test_is_match(&test2, pat1));
  TEST_ASSERT(_test_is_match(&test2, pat2));
  TEST_ASSERT(_test_is_match(&test2, pat3));
}

DEFINE_TEST(test__conjunctive_complex_patterns) {
  const char *pat1 = "^foo$";
  const char *pat2 = "ba";
  const char *pat3 = "^foo$,ba";

  const struct test_info test1 = {.name = "foo"};
  const struct test_info test2 = {.name = "bar"};

  TEST_ASSERT(_test_is_match(&test1, pat1));
  TEST_ASSERT(!_test_is_match(&test1, pat2));
  TEST_ASSERT(_test_is_match(&test1, pat3));

  TEST_ASSERT(!_test_is_match(&test2, pat1));
  TEST_ASSERT(_test_is_match(&test2, pat2));
  TEST_ASSERT(_test_is_match(&test2, pat3));
}
